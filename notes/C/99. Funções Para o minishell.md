&nbsp; Segue abaixo explicação de algumas das funções permitidas para o projeto "minishell"

```c
int access(const char *pathname, int mode)
```
&rdsh; Pertencente à biblioteca `unistd.h`, esta função checa se o processo que a invocou pode acessar o ficheiro em `pathname`, caso pathname seja sym-link, ele sera deferenciado. O `modo` especifica qual acessibilidade será checada, pode conter valor `F_OK`, ou uma *mask* consistindo do bitwise `OR` de um ou mais  dos seguintes valores, `R_OK`, `W_OK` e `X_OK`. O valor `F_OK` testa se o ficheiro existe. `R_OK`, `W_OK` e `X_OK` testam se o ficheiro existe e o processo possui permissão para ler, escrever e executar, respectivamente.

&nbsp; A checagem é feita usando o UID e GID real do processo, ao invés do ID efetivo como quando tentamos de fato uma operação (ex: `open()`) no arquivo. Isso permite aos programa determinar as autorizações do usuário.

&nbsp; Em caso de sucesso (possui todas as permissões testadas), retorna 0. Em caso de erro (O usuário não possui uma das permissões testadas, ou algum erro ocorreu), a função retornará -1, e `errno` será definido apropriadamente.

```c
char *getcwd(char *buf, size_t size)
```
&rdsh; Esta função adiciona o *pathname* absoluto do diretório de trabalho atual no array apontado por `buf`. O *pathname* copiado para o array não pode conter links simbolicos. O argumento `size` é o tamanho em bytes do array apontado por `buf`. Caso `buf` seja `NULL`, o comportamento do `getcwd()` é `undefined`.

&nbsp; Em caso de sucesso, `getcwd()` retorna `buf`. Caso contrário, retornará `NULL` e definirá `errno` para indicar o erro.

```c
int chdir(const char *path)
```
&rdsh; `chdir()` faz com que o diretório apontado por `path` se torne o diretório de trabalho atual.

&nbsp; Em caso de sucesso, retorna 0. Caso contrário, retorna -1 e `errno` é definido para indicar o erro.

```c
int unlink(const char *pathname)
```
&rdsh; Deleta um nome do *filesystem*. Caso o nome seja o último link para um ficheiro, e nenhum processo tenha o ficheiro aberto, o mesmo será deletado, e o espaço que estava a ser usado ficará disponível para reusar.

&nbsp; Caso o nome seja o último link para o ficheiro, porém algum processo ainda o possua aberto, o ficheiro permanecerá existindo até que o último *file descriptor* referenciando o mesmo seja fechado.

&nbsp; Caso o nome seja uma referência a um link simbólico, o link será removido.

```c
int execve(const char *pathname, char *const _Nullable argv[],
		   char *const _Nullable envp[])
```
&rdsh; Executa o programa referido por `pathname`. Faz com que o programa que está a ser executado atualmente pelo processo invocador seja substituído por um novo programa, com uma nova *stack*, *heap* e *data segments*.

```c
dup
```
&rdsh;

```c
dup2
```
&rdsh;

```c
pipe
```
&rdsh;

```c
opendir
```
&rdsh;

```c
readdir
```
&rdsh;

```c
closedir
```
&rdsh;

```c
isatty
```
&rdsh;

```c
ttyname
```
&rdsh;

```c
ttyslot
```
&rdsh;

```c
ioctl
```
&rdsh;

```c
getenv
```
&rdsh;

```c
tcsetattr
```
&rdsh;

```c
tcgetattr
```
&rdsh;

```c
tgetent
```
&rdsh;

```c
tgetflag
```
&rdsh;

```c
tgetnum
```
&rdsh;

```c
tgetstr
```
&rdsh;

```c
tgoto
```
&rdsh;

```c
tputs
```
&rdsh;
