***
## Bibliotecas
```c 
#include <stdio.h>
```
&rdsh; Biblioteca onde se encontra a função `printf()`.

```c
#include <unistd.h>
```
&rdsh; Biblioteca onde se encontram as funções `write()`, `read()`, `open()`, `close()`, etc.

```c
#include <stdlib.h>
```
&rdsh; Biblioteca onde se encontram as funções `malloc()`, `free()`, `calloc()`, `atoi()`, etc.

```c
#include <locale.h>
```
&rdsh; Biblioteca responsável por indicar o local para adicionar acentuação.

```c
#include <stdbool.h>
```
&rdsh; Biblioteca que permite o uso da variável booleana.

```c
#include <stdarg.h>
```
&rdsh; Biblioteca necessária para trabalhar com Variadic Arguments.


***
## Funções
```
tipo_do_retorno   nome_da_função(argumento1, argumento2, etc)
{
	[...]
}
```

```c
//Exemplo
int main(void)
{
	[...]
	return (0);
}
```

`int` &rarr; O que a função irá retornar.

`main` &rarr; Nome da função.

`(void)` &rarr; Argumento(s) que a função recebe (no caso atual, nenhum.)

`{` &rarr; Abertura do conteúdo da função.

`[...]` &rarr;  Conteúdo da função.

`return (0)` &rarr;  Retorno da função e o valor que será retornado.

`}` &rarr; Fim do conteúdo da função.

> [!IMPORTANT] Importante
> &nbsp; Algumas funções podem não retornar nada, tendo então o tipo `void`.


***

## Variáveis

#### Tipos básicos
&nbsp; Existem ao nível básico em C, 3 tipos de váriáveis.

`char`
&rdsh; Responsável por guardar 1 character, possui 1 byte.

&rdsh; Para saber os possíveis valores, consultar a tabela ASCII.

`int`
&rdsh; Responsável por guardar um número inteiro, geralmente possui 4 bytes, porém pode mudar conforme a arquitetura da máquina.

&rdsh; Pode conter um número entre -2.147.483.648 e 2.147.483.647 no caso de possuir 4 bytes.

>[!NOTE] Lembre
> Os tipos `int` e `char` são intercambíveis desde que o int não passe de 127 (valor máximo pra um char).

`void`
&rdsh; Não possui qualquer valor, usado para indicar funções que não retornam valores ou que não recebem argumentos, e para indicar endereços com o uso de ponteiros sem indicar o tipo de variável guardada neste mesmo endereço.
#### Tipos intermediários

&nbsp; Para além disso, também possuímos outros tipos de variáveis, como:

`bool`
&rdsh; Seus possíveis valores são `TRUE` e `FALSE`, sendo TRUE = 1 e FALSE = 0.
&rdsh; Se encontra na biblioteca `stdbool.h`.

`float`
&rdsh;  Responsável por guardar números decimais.

#### Declarando uma variável

&nbsp; Para declarar uma variável, devemos escrever seu tipo e nome e depois atribuimos um valor.

Ex:

```c
int x;

x = 10;
```
&nbsp; A atribuição de valor não será necessariamente logo após a sua declaração, podemos atribuir um valor ao meio da função por exemplo.

&nbsp; Para além disso, podemos atribuir também o valor da variável no momento de sua criação.

Ex:

```c
char letra = 'a';
```
&nbsp; Porém em alguns casos pode ser considerado como má prática.


***
## Operadores

&nbsp; Uma das mais importantes partes da programação, são as operações matemáticas, elas são de suma importância para o bom funcionamento de nossos códigos.


#### Operadores Unitários
```c
a++;
```
&rdsh; Acrescenta em 1 o valor da variável.

```c
a--;
```
&rdsh; Diminui em 1 o valor da variável.

#### Operadores Binários
##### Operadores Aritméticos
```c
a + b;
```
&rdsh; Soma.

```c
a - b;
```
&rdsh; Subtração ou diferença.

```c
a * b;
```
&rdsh; Multiplicação.

```c
a / b;
```
&rdsh; Divisão, note que caso estejamos a trabalhar com `int`, o resultado será apenas a divisão inteira, no caso `5 / 2 = 2`.

```c
a % b;
```
&rdsh; Resto da divisão, conhecido como módulo na programação (O módulo como visto na matemática é descrito na programação como "Valor absoluto", onde o sinal positivo ou negativo não importa, apenas o número em si.
&rdsh; No caso acima, temos `5 % 2 = 1`.

##### Operadores de Atribuição

&nbsp; Operadores de atribuição são utilizados para atribuir ou alterar os valores de uma dada variável. No exemplo abaixo, vamos seguir a jornada da variável inteira `a` pelos operadores.

```c
a = 10;
```
&rdsh; Atribuimos o valor 10 à variável `a` com apenas um sinal "`=`".

```c
// É o mesmo que a = a + 5. Ou então, a = 10 + 5.
a += 5;
```
&rdsh; Com o operador `+=`, nós acrescentamos à `a`o valor 5, passamos a ter então `a = 15`.

```c
a -= 3;
```
&rdsh; Através do operador `-=`, nós diminuímos 3, e passamos a ter `a = 12`.

```c
a *= 2;
```
&rdsh; Multiplicamos então `a` por 2, tendo agora `a = 24`.

```c
a /= 3;
```
&rdsh; Dividimos por 3 e adquirimos `a = 8`.

```c
a %= 5;
```
&rdsh; E no final pegamos o resto da divisão de `a` por 5, resultando em `a = 3`, uma vez que `8 / 5 = 1 e resto 3`.
##### Operadores Racionais

&nbsp; Os operadores racionais são responsáveis pela comparação entre 2 valores diferentes, retornando **1 ou TRUE** caso a comparação seja verdadeira e **0 ou FALSE** caso a comparação seja falsa. Estes operadores são principalmente utilizados para loops e condicionais.

```c
a < b
```
&rdsh; `a` menor que `b`?

```c
a <= b
```
&rdsh; `a` menor ou igual a `b`?

```c
a > b
```
&rdsh; `a` maior que `b`?

```c
a >= b
```
&rdsh; `a` maior ou igual a `b`?

```c
a == b
```
&rdsh; `a` igual a `b`?

```c
a != b
```
&rdsh; `a` diferente de `b`?

##### Operadores Lógicos

&nbsp; Operadores lógicos são a chave básica da matemática booleana, são eles que nos permitem verificar condições de forma coletiva. Seu uso é necessário quando queremos que mais de uma condição seja verdadeira, falsa ou quando apenas uma condição de um conjunto necessita ser verdadeira para nosso código funcionar.

###### AND

```c
(condição1 && condição2)
```

&rdsh; O operador "**AND**" é responsável pela verificação de 2 ou mais condições, ela retorna 1 ou TRUE caso todas as condições sejam verdadeiras.

Ex:

```c

[...]

a = 10;
b = 20;
c = 30;

if (a < b && b > c) //Já veremos o que esse "if" significa
{
	printf("b is the greatest!");
}
```

&rdsh; Para que a nossa função `printf()` ocorra, necessitamos que `a` seja menor que `b` e que `b` seja maior que `c`. Nossa primeira condição é verdadeira, porém a segunda não, o que faz com que o código pule tudo o que se encontra dentro do bloco `if`.

###### OR

```c
( condição1 || condição2)
```

&rdsh; O operador "**OR**" funciona como um seletor que retorna 1 ou TRUE sempre que pelo menos 1 das condições seja verdadeira.

Ex:

```c

[...]

a = 10;
b = 5;
c = 30;

if (a < b || a < c) //Já veremos o que esse "if" significa
{
	printf("a is not the greatest, someone else is!");
}
```

&rdsh; Na nossa função, caso algum número seja maior que `a`, nosso bloco `if` irá ocorrer, na primeira comparação, vemos que `a` não é menor que `b`, porém na segunda, temos `a` meor que `c`, e como nosso operador "**OR**" precisa que pelo menos uma condição seja verdadeira, nosso bloco if irá funcionar.

###### NOT

```c
!condição
```

&rdsh; O operador "**NOT**", tem apenas a função de inverter o resultado dado pela condição, entenderemos melhor o seu propósito no próximo tópico.

##### Operadores de Bits

&nbsp; Estes operadores são utilizados para manipulação de bits, eles são necessários quando queremos trabalhar com esses valores menores, uma vez que toda a computação usa como referência os bytes para trabalhar.

> [!TIP] 1 byte = 8 bits.

&nbsp; Para exemplificar, tomemos 2 números em específico.
42 e 95 que em binário são 00101010 e 01011111 respectivamente.

>[!WARNING] Atenção
>&nbsp; Importante em primeiro lugar não confundirmos os operadores de bit com os operadores lógicos, embora a lógica seja a mesma, um serve para matemática booleana e o outro trabalha com os bits dentro de um byte.
###### Bitwise AND

&nbsp; O operador "**AND**" para bits funciona com a mesma lógica que a usada no operador lógico, ela irá retornar 1 onde em ambos os casos, tivermos 1.
Ex:

```c
{
	unsigned char a = 42; //00101010 
	unsigned char b = 95; //01011111
	unsigned char c;
	
	c = a & b;   //00001010
}
```

&rdsh; No caso acima, o byte `c`  irá ter o valor 1 nos bits onde tanto em `a` quanto em `b`, o bit se encontre a 1, neste caso temos como resultado o número binário 00001010 ou 10 em decimal.

###### Bitwise OR

&nbsp; O operador "**OR**" para bits trabalha da mesma forma que o seu correspondente lógico.

```c
{
	unsigned char a = 42; //00101010 
	unsigned char b = 95; //01011111
	unsigned char c;
	
	c = a | b;            //01111111
}
```

&rdsh; Temos como resultado `c = 127`.

###### Left Shift

&nbsp; Este operador serve para mover os bits do byte para a esquerda, adicionando 0 onde há essa substituição.

```c
{
	unsigned char a = 42; //00101010 
	unsigned char b;
	unsigned char c;
	
	b = a << 1;           //01010100
	c = a << 2;           //10101000
}
```

&rdsh; Temos como resultado `b = 84` e `c = 168`.

###### Right Shift

&nbsp; Similar ao **Left Shift**, porém move os bits para direita.

```c
{
	unsigned char a = 42; //00101010 
	unsigned char b;
	unsigned char c;
	
	b = a >> 1;           //00010101
	c = a >> 2;           //00001010
}
```

&rdsh; Portanto temos `b = 21` e `c = 10`

###### Bitwise NOT

&nbsp; O operador **NOT** na manipulação de bits faz a inversão de cada bit dentro de um byte.

```c
{
	unsigned char a = 42; //00101010 
	unsigned char b;
	
	b = ~a;               //11010101
}
```

&rdsh; Desta forma temos `b = 213`

###### Bitwise XOR

&nbsp; O operador **XOR** retorna 1 apenas quando um ou outro é verdadeiro, quando ambos são falsos ou ambos são verdadeiros, ele retorna 0.

```c
{
	unsigned char a = 42; //00101010 
	unsigned char b = 95; //01011111
	unsigned char c;
	
	c = a ^ b;            //01110101
}
```

&rdsh; Resultando em `c = 117`

#### Operadores Ternários

&nbsp; Também conhecidos como operadores condicionais, os operadores ternários são apenas 2, e agem em conjunto para oferecer uma alternativa à um conjunto if else de baixa complexidade.

&nbsp; Esses 2 operadores são `?` e `:`.

```c
(condição) ? (o que fazer caso seja veradeiro) : (o que fazer caso seja falso);
```

Ex:

```c
int x = 10;
int y = 20;

(x > y) ? printf("x is bigger") : printf("y is bigger");
```

&nbsp; Podemos descrever basicamente como 3 blocos separados por 2 operadores, o primeiro bloco apresenta a condição que será testada, seguida do operador ternário `?`, após isso, temos o segundo bloco, que é o que fazer caso a condição resulte em 1 ou TRUE, seguido do operador `:`, e para finalizar, o terceiro bloco, que é o que será feito caso a condição de prove falsa.

***
## Condicionais

#### if & else
&nbsp; Em C e diversas outras linguagens temos a capacidade de definir blocos de código que só serão executados caso uma condição (ou um conjundo delas) seja atendida. Para isso fazemos uso das declarações `if` e `else`.

&nbsp; Observe o exemplo abaixo.

```c
{
	[...]
	
	if (x < y)
	{
		printf("x is less than y");
	}
	else if (x == y)
		printf("x is equal to y.");
	else
		printf("x is bigger than y.");
		
	[...]
}
```

&nbsp; No exemplo acima, temos primeiramente uma condição `if` seguida de um bloco de código, para que o mesmo seja executado é necessário que `x` seja menor que `y`. Imaginemos que a primeira condição não se satisfaça, passaremos então adiante.

&nbsp; No caso descrito, temos para além do primeiro if, um `else if` e um `else`, esses blocos trabalham todos em conjunto, onde apenas um deles irá ser executado, caso o primeiro `if ` não seja, iremos verificar os `else if` um por um, na ordem escrita, caso nenhuma das condições seja verdadeira, podemos ter um `else`, o qual não possui condição nenhuma, podemos descrever de certa forma, que a condição para que ele aconteça, é que nenhuma outra condição seja verdadeira.

>[!IMPORTANT] Dica:
> &nbsp; Note que no `else if` e no `if`, usamos apenas a linha de código, sem abrirmos o bloco com as chaves `{ }`, isso é permitido quando temos apenas uma linha de código para ser executada após a condição.
#### switch & case
&nbsp; Para além do conjunto `if` e `else`, nós também possuimos o trio `switch`, `case` e `default`, veja o exemplo abaixo:

```c
{
	[...]
	switch (x)
	{
		case 1:
			printf("x = 1");
			break ;
		case 2:
			printf("x = 2");
			break ;
		case 10:
			printf("x = 10");
			break ;
		default:
			printf("x != 1, x != 2, x != 10);
			break;
	}
	[...]
}
```

&rdsh; A *keyword* `switch`, funciona como um seletor, em que uma dada variável, é comparada com cada `case`, caso nenhuma comparação se demonstre verdadeira, iremos usar a opção `default`.

>[!Warning] Atenção
>&nbsp; No conjunto switch case, devemos utilizar sempre um `break` após terminarmos o nosso `case` selecionado, isso é necessário para que a execução do bloco seja descontinuada, uma vez que ao contrario do `if` & `else`, os casos são todos testados apesar de algum deles já ter sido confirmado.

***

## Loop

#### while

&nbsp; Podemos realizar loops com o uso da *keyword* `while`, ela serve para que um bloco de código seja realizado enquanto as condições indicadas forem verdadeiras.

```c
{
	int x;

	x = 0;
	while (x < 10)
	{
		printf("%d ", x);
		x++;
	}
}
```

&rdsh; No exemplo acima, iremos imprimir o valor de `x` e incrementá-lo a cada iteração, ocorrendo ao todo 10 vezes, e imprimindo "1 2 3 4 5  6 7 8 9 ".

#### do & while

&nbsp; Podemos usar também a *keyword* `do` em conjunto do `while`, desta forma, o bloco de código irá ser executado somente uma vez, e só após essa primeira iteração é que será verificada a condição para que o bloco se repita.

&nbsp; Para tal, usamos a seguinte sintaxe:

```c
{
	int x;
	
	x = 10;
	do
	{
		printf("%d ", x);
		x++;
	}
	while (x < 5);
}
```

&nbsp; No exemplo acima, o bloco de código irá ocorrer a primeira vez, porém não se repetirá, uma vez que a condição para o loop não é atendida, portanto teremos como impressão apenas "10 ".

#### for

&nbsp; Para finalizar, temos a *keyword* `for` para trabalharmos nossos loops.
```c
{
	int x;

	for (x = 0; x < 10; x++)
	{
		[...]
	}

}
```

&nbsp; Iremos dividir nosso loop `for` em 3 partes:

1. `x = 0`
&rdsh; "Linha" de código que será executada uma vez antes do bloco ser executado.

3. `x < 10`
&rdsh; Condição para que o bloco de código aconteça.

5. `x++`
&rdsh; "Linha" de código que será executada toda vez que o bloco terminar de ser executado.

&nbsp; Veja uma comparação entre um loop `while` e `for` que possuem a mesma função.

```c
#include <stdio.h>

{
	int x;

	x = 0;
	while (x < 10)
	{
		printf("%d ", x);
		x++;
	}

	for (x = 0; x < 10; x++)
		printf("%d ", x);
}
```

***

## Macros

&nbsp; Macros são "variáveis" ou simplesmente palavras que possuem valores constantes definidos pelo usuário. Podemos definir macros em nosso programa com o uso do `#define`.
```c
#include <stdio.h>
#define TEXT "this is a text\n"
#define NUMBER 10

int main(void)
{
	int x;

	x = 0;
	while (x < NUMBER)
	{
		printf(TEXT);
		x++;
	}
}
```

&nbsp; No exemplo dado, os macros definidos anteriormente no "*header*" serão substituidos pelos valores correspondentes, portanto teremos a impressão do texto "this is a text" 10 vezes.

***

## Vetores

&nbsp; Um vetor, nada mais é que um conjunto de variáveis, para criarmos um vetor, temos como principal maneira as seguintes opções.

```c
{

	int x[10];

	x[0] = 1;
	x[1] = 2;
	[...]
	x[9] = 10;
	printf("%d\n", x[5]);
}
```

&nbsp; No caso acima, temos o vetor x, com tamanho 10. 

```c
{
	int x[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
	[...]
}
```
&nbsp; Neste outro caso, temos a atribuição de valores juntamente com a declaração do vetor, é importante notar que esta maneira de escrevermos os valores que serão atribuidos, só funcionam quando feito junto da declaração, para atribuirmos valores após a declaração, temos de fazer como no primeiro caso.
>[!TIP] Dica
>&nbsp; Note que a primeira casa de um vetor é a casa 0, e por consequência, a última casa será "*size - 1*", ou neste caso, a casa 9.

&nbsp; Como alternativa, podemos também descrever um vetor através de ponteiros, algo que veremos em breve.

>[!NOTE] Anote
>&nbsp; Em C, as strings são principalmente descritas como um vetor de `char`.

***

## Matriz

&nbsp; Similar aos vetores, nós possuimos as matrizes, a diferença é que ao invés de serem um conjunto de variáveis, estas são um conjunto de vetores, que por sua vez sim, guardam variáveis.

```c
{
	int campo[3][10];
	int x;
	int y;

	x = 0;
	while (x < 3)
	{
		y = 0;
		while (y < 10)
		{
			campo[x][y] = x * 10 + y;
			y++;
		}
		x++;
	}
}
```

&nbsp; Neste breve exemplo, temos 2 loops aninhados para provêr os devidos valores à matriz "campo", note que corremos cada variável `y` de cada vetor `x`, e concedemos os seus devidos valores.
***

## Ponteiros

#### Como funcionam

&nbsp; Talvez um dos tópicos mais complexos para quem está a começar a aprender C, os ponteiros são variáveis que servem para guardar endereços de memória para que possamos trabalhar com os valores guardados nesses espaços.

&nbsp; Façamos uma pequena análise do *snippet* abaixo.

```c
{
	int x;
	int *p;    //Também podemos escrever: int* p;

	x = 1;
	p = &x;
}
```
&nbsp; Primeiramente declaramos nossas duas variáveis, `x` e `p`, sendo `p` um ponteiro de números inteiros, portanto, ele só será capaz de guardar endereços de variáveis inteiras.

&nbsp; Note que para declarar o ponteiro `p`, foi utilizado um asterisco `*`, porém ao designarmos um valor para p, não o utilizamos, isto se dá pelo fato de que o asterisco possui 2 significados.

1. &nbsp; Ponteiro: Quando **CRIAMOS** uma variável que irá guardar um endereço como no caso acima, usamos um asterisco `*` para indicar que o mesmo é um ponteiro, uma forma mais simples de visualizarmos seria: `int* p`, em que a variável `p`, é do tipo `int*`, no caso um ponteiro de endereço.

2. &nbsp; Conteúdo do Endereço: A segunda maneira de usarmos o asterisco é para indicarmos que queremos o conteúdo contido dentro de um dado endereço. Veja o exemplo abaixo.
```c
{
	int x;
	int *p;

	x = 1;
	p = &x;
	printf("%p \n", p);  //Irá imprimir o endereço de x
	printf("%d \n", *p); //Irá imprimir o conteúdo do endereço de x, ou seja, x
	printf("%p \n", &p); //Irá imprimir o endereço de p
}
```
&nbsp; Para concretizarmos a idéia, vamos visualizar o processo de mais uma maneira.

1. &nbsp; Criamos as variáveis `x` e `p`. Imaginemos que elas possuem o endereço 2530 e 2940 respectivamente.
2. &nbsp; Atribuimos à variável `x` o valor 1.
3. &nbsp; Atribuimos à variável `p`, o endereço de `x` (`&x`), no caso 2530.
4. &nbsp; Imprimimos o valor de p, que no caso é `&x` "2530".
5. &nbsp; Imprimimos o conteúdo de `p` (`*p` = `*&x`=`*2530`=`x`=`1`).
6. &nbsp; Imprimimos o endereço de `p` (`&p`) 2940.

&nbsp; Apesar de um pouco confuso, o quinto passo exemplifica o funcionamento do `*` para obtermos o conteúdo, e como demonstrado no sexto passo, a variável p, que tem como conteúdo o endereço de `x`, também possui seu próprio endereço, afinal, como toda variável, ela precisa ser guardada em algum lugar na memória, e isso nos permite ter aninhamentos de ponteiros, ou mais conhecido como ponteiros de ponteiros `int **pdp`.

#### Ponteiros & Vetores

&nbsp; Como dito anteriormente, ponteiros e vetores são 2 formas de demonstrarmos a mesma coisa e portanto são intercambíveis.

Consideremos o *snippet* abaixo.
```c
{
	int x[5];
	int i;

	i = 0;
	while (i < 5)
	{
		x[i] = i;
	}
}
```
&nbsp; Quando criamos um vetor, definimos seu tipo, e quantas casas o mesmo possui, e para atribuirmos um valor para uma dada casa deste vetor, é necessário especificarmos qual a casa que desejamos (`x[n]`).

&nbsp; Caso tentemos atribuir um valor sem especificarmos a casa, nos depararemos com um erro, Ex:

```c
{
	int x[5];

	x = 10;   //Não será possível compilar um arquivo com isto.
}
```
&nbsp; Isso ocorre porquê a variável que definimos como vetor, guarda especificamente um endereço, mais especificamente o endereço da primeira casa.

&nbsp; Quando atribuimos um valor à casa de um vetor "`x[n] = y;`", estamos a acessar o *endereço da variável na casa `n` do vetor `x` e atribuindo o valor `y`*, . No exemplo mais simples, a casa 0, podemos aplicar tanto a idéia de vetor (`x[0] = y;`), quanto a idéia de ponteiro (`*x = y;`).

***

## Ponteiro de Função

&nbsp; Em C, assim como ponteiros de variáveis, também é possível criar ponteiros de funções. Tais são criados e usados da seguinte maneira.

```c
void printvalue(int i)
{
	printf("i = %d\n", i);
}

int main (void)
{
	void (*pv_ptr)(int);

	(pv_ptr) = &ft_printvalue;
	(*pv_ptr)(5);    //Irá invocar a função printvalue com o valor 5
}
```

&nbsp; No exemplo dado acima, temos a função `printvalue`, e um ponteiro `pv_ptr`, Note que na declaração do ponteiro foi necessário o uso de parenteses para que pudéssemos escrever o ponteiro de função apropriadamente, isso se dá pelo fato de que `void *pv_ptr(int)` seria a declaração de uma função que retorna um ponteiro void, e não é isso que desejamos. Para além disso, existem alguns detalhes importantes sobre ponteiros de função.

1. Diferente de ponteiros normais, um ponteiro de função aponta para um código e não para um endereço de memória. Normalmente o ponteiro de função guarda o início de um código executável.
2. Como ponteiros de função não guardam dados de fato, nós não alocamos e desalocamos memoria com eles, diferente de ponteiros comuns.
3. O nome de uma função também pode ser usado para adquirirmos o endereço do mesmo. Por exemplo, poderiamos remover os operadores de endereço `&` e `*` do código acima, e o programa ainda funcionaria.

```c
int main (void)
{
	void (*pv_ptr)(int);

	(pv_ptr) = ft_printvalue;   // Retiramos o &
	pv_ptr(5);                  // Retiramos o *
}
```

&nbsp; Para finalizar, assim como podemos ter ponteiros de ponteiros, intercambível com vetor de ponteiros, nós podemos criar um vetor de ponteiros de função.

```c
void sum(int a, int b)
{
	return (a + b);
}

void sub(int a, int b)
{
	return (a - b);
}

int main(void)
{
	void (*op[2])(int, int);

	op[0] = sum;
	op[1] = sub;
	printf("%d\n", op[0](2,3));
}
```
***

## Structs

&nbsp;

***

## Enums

***

## Typedef

***

## Recursividade

***

## Variadic Argument
***

